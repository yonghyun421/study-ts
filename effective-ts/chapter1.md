# 1장. 타입스크립트 알아보기

## Item 1. 타입스크립트와 자바스크립트의 관계 이해하기

### 타입스크립트의 특징

- 타입스크립트는 문법적으로 자바스크립트의 상위집합이다.
- 타입스크립트 파일은 .ts(또는 .tsx) 확장자를 사용한다.
- 기존 자바스크립트로 작성된 코드를 그대로 유지하면서 일부분에만 타입스크립트 적용이 가능하다.
- 타입 구문을 사용하는 순간부터 자바스크립트는 타입스크립트 영역으로 들어가게 된다.
  - 모든 자바스크립트는 타입스크립트이지만, 모든 타입스크립트가 자바스크립트는 아니다.
- 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다.
  - 타입스크립트는 타입 구문 없이도 오류를 잡을 수 있지만, 타입 구문을 추가한다면 훨씬 더 많은 오류를 찾아낼 수 있다.
  - 코드의 **의도**가 무엇인지 타입 구문을 통해 타입스크립트에게 알려줄 수 있기 때문에 코드의 동작과 의도가 다른 부분을 찾을 수 있다.
  - 그렇기 때문에 의도를 명확히 해서 타입스크립트가 잠재적 문제점을 찾을 수 있게 해야한다.

## Item 2. 타입스크립트 설정 이해하기

- 타입스크립트 설정 파일(tsconfig.json) 생성하기

```bash
tsc --init
```

- **noImplicitAny**
  - 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.
  ```tsx
  function add(a, b) {
    return a + b;
  }

  // noImplicitAny가 해제되어있을때는 위와 같이 작성해도 any 타입으로 간주(암시적 any)되기
  // 때문에 에러가 발생하지 않지만 설정해준 후에는 아래와 같이 타입을 명시해주어야 한다.

  function add(a: number, b: number) {
    return a + b;
  }
  ```
- **stirctNullChecks**
  - null과 undefined가 모든 타입에서 허용되는지 확인하는 설정.
  ```tsx
  const x: number = null; // 정상, null은 유효한 값입니다.

  // 그러나 strictNullChecks를 설정하면

  const x: number = null;
  // ~ 'null' 형식은 'number' 형식에 할당할 수 없습니다.
  // 위 메세지처럼 오류가 발생한다.
  // null 대신 undefined를 써도 같은 오류가 발생한다.

  const x: numver | null = null;
  // 다음과 같이 의도를 명시적으로 드러냄으롴써 오류를 고칠 수 있다.
  ```
- strictNullChecks를 설정하려면 noImplicitAny를 먼저 설정해야 한다.
- 이처럼 타입스크립트에서 엄격한 체크를 하고 싶다면 **strict** 설정을 고려해야 한다.

## Item 3. 코드 생성과 타입이 관계없음을 이해하기

### 타입스크립트 컴파일러의 역할

- 최신 타입스크립트/ 자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일(transpile)한다.
- 코드의 타입 오류를 체크한다.

---

- 타입 오류가 있는 코드도 컴파일이 가능하다.
  - 컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능하다.
  - 만약 오류가 있을 때 컴파일하지 않으려면 tsconfig.json에 noEmitOnError를 설정하거나 빌드 도구에 동일하게 적용하면 된다.
- 런타임에는 타입 체크가 불가능하다.
  - 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거된다.
  - 타입 정보를 유지하는 방법으로는 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 **태그** 기법이 있다.
  - 타입을 클래스로 만들어 타입과 값을 둘 다 사용하는 기법도 있다.
- 타입 연산은 런타임에 영향을 주지 않는다.
  - 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 자바스크립트 연산을 통해 변환을 수행해야 한다.
- 런타임 타입은 선언된 타입과 다를 수 있다.
  - 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다. 타입이 달라지는 혼란스러운 상황을 가능한 한 피해야 한다. 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 한다.
- 타입스크립트 타입으로는 함수를 오버로드할 수 없다.
  - 타입스크립트에서는 타입과 런타임의 동작이 무관하기 때문에, 함수 오버로딩은 불가능하다.
- 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

## Item 4. 구조적 타이핑에 익숙해지기

- 자바스크립트는 본질적으로 덕 타이핑(duck typing) 기반이기 때문에 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다.

### Case1

```tsx
interface Vector2D {
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

const v: NamedVector = { x: 3, y: 4, name: "Zee" };
calculateLength(v); // 정상, 결과는 5
```

### Case2

```tsx
interface Vector3D {
	x: number;
	y: number;
	z: number;
}

// 벡터의 길이를 1로 만드는 정규화 함수를 작성한다.
function normalize(v: Vector3D) {
	const length = calculateLength(v);
	return {
		x: v.x / length,
		y: v.y / length,
		z: v.z / length,
	};
}
// 그러나 이 함수는 1이 아닌 1.41 이라는 길이를 결과로 출력한다.

> normalize({x: 3, y: 4, z: 5})
{x: 0.6, y: 0.8, z: 1}
```

### Why?

- calculateLength는 2D 벡터를 기반으로 연산하는데, 버그로 인해 z가 정규화에서 무시되어 normalize가 3D 벡터로 연산되었다.
  - vector3D와 호환되는 {x, y, z} 객체로 calculateLength를 호출하면 구조적 타이핑 관점에서 x와 y가 있기 때문에 vector2D와 호환이 된다. 따라서 오류가 발생하지 않고 타입 체커가 이 부분을 문제로 인식하지 않았다.
- 함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하기 쉽지만 타입스크립트 타입 시스템에서는 표현할 수 없다. 타입은 열려(open)있다.

```tsx
const vec3D = { x: 3, y: 4, z: 1, address: "123 Broadway" };
calculateLength1(vec3D); // 정상, NaN을 반환한다.
```

---

- 구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.

## Item 5. any 타입 지양하기

- 타입스크립트의 타입 시스템은 점진적이고 선택적이다.

### any 타입의 위험성

- any 타입에는 타입 안정성이 없다.
  - as any를 사용할 경우 타입 체커는 실제 할당된 타입이 아닌 처음 선언한 타입으로 판단하여 혼돈을 야기할 수 있다.
- any는 함수 시그니처를 무시해 버린다.
  - 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. 그러나 any 타입을 사용하면 이런 약속을 어길 수 있다.
- any 타입에는 언어 서비스가 적용되지 않는다.
  - 어떤 심벌에 타입이 있다면 타입스크립트 언어 서비스는 자동완성 기능과 적절한 도움말을 제공하지만 any 타입을 갖는 경우 아무런 도움을 받을 수 없다.
  - Rename Symbol 기능을 이용하여 새 이름을 입력하면 프로젝트 내의 심벌 이름이 모두 변경되지만 any 타입의 심벌은 바뀌지 않는다.
- any 타입은 코드 리팩터링 때 버그를 감춘다.
- any는 타입 설계를 감춰버린다.
  - 상태 객체의 설계를 감춰버린다. 그렇기 때문에 타입 설계가 불분명해진다.
- any는 타입시스템의 신뢰도를 떨어뜨린다.
  - any 타입을 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있다.
  - 타입스크립트는 개발자의 삶을 편하게 하는 데 목적이 있지만, 코드 내에 존재하는 수많은 any 타입으로 인해 타입 오류를 고쳐야 하고 여전히 머릿속에 실제 타입을 기억해야 하기 때문에 자바스크립트보다 일을 더 어렵게 만들기도 한다.
  - 타입이 실제 값과 일치한다면 타입스크립트가 타입 정보를 기억해 주기 때문에 타입 정보를 기억해 둘 필요가 없다.
